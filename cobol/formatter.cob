       >>SOURCE FORMAT FREE

*> To Compile:
*> cobc -x formatter.cob

*> To Run:
*> ./formatter {absolute filepath}* optional

IDENTIFICATION DIVISION.
PROGRAM-ID. formatter.
AUTHOR. Nolan Donley
DATE-WRITTEN. October 30th 2020
ENVIRONMENT DIVISION.
  INPUT-OUTPUT SECTION.
  FILE-CONTROL.
    SELECT TextFile ASSIGN USING WS-FILENAME
      ORGANIZATION IS SEQUENTIAL.

DATA DIVISION.
  FILE SECTION.
  FD TextFile.
  01 FileLines.
    02 FileWords PIC A(256).

WORKING-STORAGE SECTION.

*> File and command line variables
01 WS-FILE-EOF PIC Z(1).
01 WS-FILENAME PIC X(80).
01 WS-ARGS PIC X(50).
01 WS-ARGS-LENGTH PIC 9(2).

*> Display variables
01 WS-OUTPUT-LINE PIC X(80) VALUE "   1".
01 WS-OUTPUT-LINE-INDEX PIC 9(2) VALUE 6.
01 WS-OUTPUT-LINE-COUNT PIC 9(2) VALUE 0.

*> Split words variables
01 WS-SUB PIC 9(4) COMP.
01 WS-SUB1 PIC 9(4) COMP VALUE 0.
01 WS-START1 PIC 9(4) COMP VALUE 1.
01 WS-WORD-INDEX PIC 9(4) COMP VALUE 0.

*> Display words variables
01 WS-ARRAY PIC X(20) OCCURS 0 TO 9999 DEPENDING ON WS-WORD-INDEX.
01 WS-INDEX PIC 9(3) VALUE 1.
01 WS-LENGTH PIC 9(2).

*> Update Max and Min Variables
01 WS-CHAR-INDEX PIC 9(4) USAGE BINARY.
01 WS-LONG-LINE PIC X(80) VALUE "LONG".
01 WS-SHORT-LINE PIC X(80) VALUE "SHORT".
01 WS-SHORT-LINE-LENGTH PIC 9(2) VALUE 0.
01 WS-LONG-LINE-LENGTH PIC 9(2) VALUE 0.
01 WS-SHORT-LINE-WORD-COUNT PIC 9(2) VALUE 0.
01 WS-LONG-LINE-WORD-COUNT PIC 9(2) VALUE 0.
01 WS-WORD-COUNT PIC 9(2) VALUE 0.
01 WS-LINE-NUMBER PIC 9(4) VALUE 200.
01 WS-NO-ZERO-LINE-NUMBER PIC ZZZ9.
01 WS-COLUMN-NUMBER PIC 9(4) VALUE 5.
01 WS-LOCATION PIC 9(4).

PROCEDURE DIVISION.

*> Read in file from the command line and save into WS-FILENAME
ACCEPT WS-ARGS FROM COMMAND-LINE
INSPECT WS-ARGS TALLYING WS-ARGS-LENGTH FOR ALL SPACES
IF WS-ARGS-LENGTH IS LESS THAN 50 THEN
  STRING WS-FILENAME DELIMITED BY SPACE
  WS-ARGS DELIMITED BY SPACE
  INTO WS-FILENAME
ELSE
  DISPLAY "Please enter an absolute filepath to a text file to format: " WITH NO ADVANCING
  ACCEPT WS-ARGS
  STRING WS-FILENAME DELIMITED BY SPACE
  WS-ARGS DELIMITED BY SPACE
  INTO WS-FILENAME
END-IF
OPEN INPUT TextFile
READ TextFile
    AT END MOVE 1 TO WS-FILE-EOF
END-READ

IF WS-FILE-EOF = 1
  CLOSE TextFile
END-IF

MOVE 0 TO WS-FILE-EOF.

PERFORM UNTIL WS-FILE-EOF = 1
    PERFORM SplitWords *> SPLIT LINE INTO WORDS ARRAY
    PERFORM DisplayWords VARYING WS-INDEX FROM 1 BY 1 UNTIL WS-INDEX = WS-WORD-INDEX *> DISPLAY EACH LINE TO OUTPUT
    MOVE ZEROS TO WS-LOCATION
    ADD WS-LINE-NUMBER WS-COLUMN-NUMBER TO WS-LOCATION
    DISPLAY WS-OUTPUT-LINE AT WS-LOCATION
    PERFORM UpdateMinMax *> UPDATE THE MIN AND MAX LINES
    PERFORM DisplayLongShort *> DISPLAY THE MIN AND MAX LINES
    READ TextFile
      AT END MOVE 1 TO WS-FILE-EOF
    END-READ
END-PERFORM

STOP RUN.

*> SPLITS LINE INTO INDIVIDUAL WORDS BY SPACE OR BY NEWLINE CHAR
SplitWords.
  PERFORM VARYING WS-SUB
        FROM 1 BY 1
        UNTIL WS-SUB > FUNCTION LENGTH(FileWords)
   COMPUTE WS-SUB1 = WS-SUB1 + 1
   IF (FileWords(WS-SUB:1) = SPACE) OR (FileWords(WS-SUB:1) = X'0D')
      ADD 1 TO WS-WORD-INDEX
      MOVE FileWords(WS-START1:WS-SUB1 - 1) TO WS-ARRAY(WS-WORD-INDEX)
      MOVE 0 TO WS-SUB1
      COMPUTE WS-START1 = WS-SUB + 1
   END-IF
   IF WS-SUB EQUAL FUNCTION LENGTH(FileWords)
      ADD 1 TO WS-WORD-INDEX
      MOVE FileWords(WS-START1:WS-SUB1) TO WS-ARRAY(WS-WORD-INDEX)
   END-IF
  END-PERFORM.

*> TAKES AN ARRAY OF WORDS, REMOVES NUMBERS AND NEW LINES, AND DISPLAYS UP TO 60 CHARS PER LINE
DisplayWords.
  INSPECT WS-ARRAY(WS-INDEX) CONVERTING "0123456789" TO "          "
  INSPECT WS-ARRAY(WS-INDEX) CONVERTING X'0A' TO " "
  PERFORM CleanWord
  INSPECT WS-ARRAY(WS-INDEX) TALLYING WS-LENGTH FOR CHARACTERS BEFORE SPACE
  IF (WS-LENGTH >= 1) AND (WS-ARRAY(WS-INDEX)(1:1) IS ALPHABETIC) THEN
    IF WS-LENGTH + WS-OUTPUT-LINE-COUNT IS LESS THAN OR EQUAL TO 60 THEN
      ADD 1 TO WS-WORD-COUNT
      IF WS-LENGTH + WS-OUTPUT-LINE-COUNT IS LESS THAN 60 THEN
        STRING WS-OUTPUT-LINE(1:WS-OUTPUT-LINE-INDEX) DELIMITED BY SIZE
        WS-ARRAY(WS-INDEX) DELIMITED BY SPACE
        INTO WS-OUTPUT-LINE
        ADD 1 TO WS-OUTPUT-LINE-INDEX
        ADD 1 TO WS-OUTPUT-LINE-COUNT
      ELSE
        STRING WS-OUTPUT-LINE(1:WS-OUTPUT-LINE-INDEX) DELIMITED BY SIZE
        WS-ARRAY(WS-INDEX) DELIMITED BY SPACE
        INTO WS-OUTPUT-LINE
      END-IF
      ADD WS-LENGTH TO WS-OUTPUT-LINE-COUNT
      ADD WS-LENGTH TO WS-OUTPUT-LINE-INDEX
    ELSE
      MOVE ZEROS TO WS-LOCATION
      ADD WS-LINE-NUMBER WS-COLUMN-NUMBER TO WS-LOCATION
      DISPLAY WS-OUTPUT-LINE AT WS-LOCATION
      PERFORM UpdateMinMax
      MOVE 0 TO WS-WORD-COUNT
      MOVE 0 TO WS-OUTPUT-LINE-COUNT
      MOVE SPACES TO WS-OUTPUT-LINE
      MOVE 6 TO WS-OUTPUT-LINE-INDEX
      DIVIDE 100 INTO WS-LINE-NUMBER
      MOVE WS-LINE-NUMBER TO WS-NO-ZERO-LINE-NUMBER
      MOVE WS-NO-ZERO-LINE-NUMBER TO WS-OUTPUT-LINE
      STRING WS-OUTPUT-LINE(1:WS-OUTPUT-LINE-INDEX) DELIMITED BY SIZE
      WS-ARRAY(WS-INDEX) DELIMITED BY SPACE
      INTO WS-OUTPUT-LINE
      ADD WS-LENGTH TO WS-OUTPUT-LINE-COUNT
      ADD WS-LENGTH TO WS-OUTPUT-LINE-INDEX
      ADD 1 TO WS-OUTPUT-LINE-INDEX
      ADD 1 TO WS-OUTPUT-LINE-COUNT
      COMPUTE WS-LINE-NUMBER = WS-LINE-NUMBER * 100
      ADD 100 TO WS-LINE-NUMBER
  END-IF
  MOVE 0 TO WS-LENGTH.

*> THIS REMOVES EXTRA SPACES FROM THE TEXT FILE
CleanWord.
  MOVE 1 TO WS-CHAR-INDEX
  PERFORM 20 TIMES
    IF (WS-ARRAY(WS-INDEX)(WS-CHAR-INDEX:1) = SPACE) THEN
      MOVE WS-ARRAY(WS-INDEX)((WS-CHAR-INDEX + 1):) TO WS-ARRAY(WS-INDEX)(WS-CHAR-INDEX:)
    ELSE
      ADD 1 TO WS-CHAR-INDEX
    END-IF
  END-PERFORM.

*> UPDATE THE MINIMUM AND MAXIMUM LINES AND ALSO THEIR LINE NUMBERS

UpdateMinMax.
  INSPECT FUNCTION REVERSE (WS-SHORT-LINE) TALLYING WS-SHORT-LINE-LENGTH FOR LEADING SPACES
  COMPUTE WS-SHORT-LINE-LENGTH = 80 - WS-SHORT-LINE-LENGTH - 5
  INSPECT FUNCTION REVERSE (WS-LONG-LINE) TALLYING WS-LONG-LINE-LENGTH FOR LEADING SPACES
  COMPUTE WS-LONG-LINE-LENGTH = 80 - WS-LONG-LINE-LENGTH - 5
  IF WS-WORD-COUNT IS LESS THAN OR EQUAL TO WS-SHORT-LINE-WORD-COUNT THEN
    MOVE SPACES TO WS-SHORT-LINE
    MOVE "SHORT" TO WS-SHORT-LINE
    STRING WS-SHORT-LINE DELIMITED BY SPACE
    WS-OUTPUT-LINE(2:) DELIMITED BY SIZE
    INTO WS-SHORT-LINE
    MOVE WS-WORD-COUNT TO WS-SHORT-LINE-WORD-COUNT
  END-IF
  IF WS-WORD-COUNT IS GREATER THAN OR EQUAL TO WS-LONG-LINE-WORD-COUNT THEN
    MOVE SPACE TO WS-LONG-LINE
    MOVE "LONG" TO WS-LONG-LINE
    STRING WS-LONG-LINE DELIMITED BY SPACE
    WS-OUTPUT-LINE DELIMITED BY SIZE
    INTO WS-LONG-LINE
    MOVE WS-WORD-COUNT TO WS-LONG-LINE-WORD-COUNT
  END-IF
  IF WS-LINE-NUMBER IS EQUAL TO 200 THEN
    MOVE SPACES TO WS-SHORT-LINE
    MOVE "SHORT" TO WS-SHORT-LINE
    STRING WS-SHORT-LINE DELIMITED BY SPACE
    WS-OUTPUT-LINE(2:) DELIMITED BY SIZE
    INTO WS-SHORT-LINE
    MOVE WS-WORD-COUNT TO WS-SHORT-LINE-WORD-COUNT
  END-IF
  MOVE 0 TO WS-SHORT-LINE-LENGTH
  MOVE 0 TO WS-LONG-LINE-LENGTH.


*> DISPLAYS THE LONG AND SHORT LINES, BECAUSE THEIR FORMAT IS DIFFERENT THAN A LINE OF TEXT FILE

DisplayLongShort.
  MOVE ZEROS TO WS-LOCATION
  ADD 200 TO WS-LINE-NUMBER
  MOVE 1 TO WS-COLUMN-NUMBER
  ADD WS-LINE-NUMBER WS-COLUMN-NUMBER TO WS-LOCATION
  DISPLAY WS-LONG-LINE(1:8) AT WS-LOCATION
  ADD 19 TO WS-LOCATION
  DISPLAY WS-LONG-LINE(11:) AT WS-LOCATION.

  MOVE ZEROS TO WS-LOCATION
  ADD 100 TO WS-LINE-NUMBER
  MOVE 1 TO WS-COLUMN-NUMBER
  ADD WS-LINE-NUMBER WS-COLUMN-NUMBER TO WS-LOCATION
  DISPLAY WS-SHORT-LINE(1:8) AT WS-LOCATION
  ADD 19 TO WS-LOCATION
  DISPLAY WS-SHORT-LINE(11:) AT WS-LOCATION.
